.TH "TracknTrace/TracknTrace/preprocessor/preProcessor.py" 3 "Smart Meter Interpreter Documentation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
TracknTrace/TracknTrace/preprocessor/preProcessor.py \- Defines smart meter data preprocessor\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBEventor\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBTracknTrace\fP"
.br
.ti -1c
.RI "namespace \fBTracknTrace\&.preprocessor\fP"
.br
.ti -1c
.RI "namespace \fBTracknTrace\&.preprocessor\&.preProcessor\fP"
.br
.RI "Defines the smart meter (pre)processor\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBAnalysisDealer\fP (\fBdata\fP, analysis)"
.br
.ti -1c
.RI "\fBCarnot\fP (Tc, Th)"
.br
.ti -1c
.RI "\fBCOP\fP (Pth, Pel)"
.br
.ti -1c
.RI "\fBDerivedCategory\fP (trends, newtrend, \fBCategoryWeights\fP, Verbose=0)"
.br
.ti -1c
.RI "\fBEnvironmentTemperatureCheck\fP (\fBdf\fP, ROCLimit=30\&.0/(12\&.0 *60 *60), ULimit=50\&.0, LLimit=\-15\&.0, VERBOSE=0)"
.br
.ti -1c
.RI "\fBEventCategorizerFcn\fP (categories, \fBdata\fP)"
.br
.RI "Summarizes all detected events to a limited group of categories, does the same as internal class function EventCategorizer but requires data\&. "
.ti -1c
.RI "\fBfracH\fP (\fBdt\fP)"
.br
.ti -1c
.RI "\fBKNMI_Resampler\fP (FileName, \fBT_Columns\fP, \fBScaleArray\fP, \fBRevertArray\fP=None, Interval='5min', header=28, Export=False, plot=False)"
.br
.RI "KNMI file reader with different output modi\&. "
.ti -1c
.RI "\fBLambda2Tex\fP (lmd, VERBOSE=0)"
.br
.ti -1c
.RI "\fBlatex_to_img\fP (\fBtex\fP)"
.br
.ti -1c
.RI "\fBlinint\fP (x1, x2, y1, y2)"
.br
.ti -1c
.RI "\fBlogFigure\fP (\fBtitle\fP, \fBdata\fP, \fBInstance\fP, fig=None, sort=None, \fBkind\fP=None, \fBverbosityLimit\fP=None)"
.br
.ti -1c
.RI "\fBLogReport\fP (msg, \fBverbosityLimit\fP=None)"
.br
.ti -1c
.RI "\fBmain\fP ()"
.br
.ti -1c
.RI "\fBPandasDHWWrapper\fP (x, \fBInhabitants\fP=1)"
.br
.ti -1c
.RI "\fBPdTtoV\fP (x, \fBT1\fP, \fBT2\fP, \fBPdhw\fP)"
.br
.ti -1c
.RI "\fBProcessData\fP ()"
.br
.RI "Example main to run if file is not being imported\&. "
.ti -1c
.RI "\fBRepairCumulatives\fP (\fBdf\fP, VERBOSE=0)"
.br
.ti -1c
.RI "\fBSimilarityCheck\fP (\fBdf\fP, \fBdata\fP, corrector, ULimit=50\&.0, LLimit=\-15\&.0, ROCLimit=30\&.0/(12\&.0 *60 *60), VERBOSE=0)"
.br
.ti -1c
.RI "\fBStochastic_Usage\fP (H, \fBSize\fP=1\&.0)"
.br
.ti -1c
.RI "\fBTimeDivision\fP (\fBdf\fP, Columns, scaleArray=None, reverse=False)"
.br
.ti -1c
.RI "\fBVisualizeEvent\fP (\fBdf\fP, event, \fBInstance\fP, Extra=None, \fBcolumns\fP=None, \fBSize\fP=None, Type='default', Save=\fBTrue\fP)"
.br
.RI "Summarizes all detected events to a limited group of categories\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBaction\fP"
.br
.RI "Ignore FutureWarning errors, floods log\&. "
.ti -1c
.RI "\fBAll\fP"
.br
.ti -1c
.RI "\fBalpha\fP"
.br
.ti -1c
.RI "\fBambiguous\fP"
.br
.ti -1c
.RI "\fBargs\fP = parser\&.parse_args()"
.br
.RI "Instantiate the parser\&. "
.ti -1c
.RI "\fBaxis\fP"
.br
.ti -1c
.RI "\fBbackend\fP"
.br
.RI "plotting backend for pandas "
.ti -1c
.RI "list \fBBaseWeights\fP"
.br
.ti -1c
.RI "\fBBestparams\fP = fmf\&.constants"
.br
.ti -1c
.RI "\fBbestSimulation\fP = pd\&.DataFrame(fmf\&.Simulate(steps=fmf\&.dataLength, err='Tavg')[\-fmf\&.dataLength:],\fBcolumns\fP=['index','err','Tavg','Tavg_pr','U','Ag','Ga','C'])"
.br
.ti -1c
.RI "\fBcategory\fP"
.br
.ti -1c
.RI "list \fBCategoryWeights\fP = [['Combined_Categories', 'User_Electric', 'User_Thermal', 'Building_thermal', 'Installation_Electric', 'Installation_Thermal', 'Weather_thermal']]"
.br
.ti -1c
.RI "\fBcEventCfg\fP = config['eventdetection']['OtherEvents']\&.split(',')"
.br
.ti -1c
.RI "\fBchained_assignment\fP"
.br
.RI "turn of error reporting for chained assignments "
.ti -1c
.RI "\fBcolor\fP"
.br
.ti -1c
.RI "\fBcolumns\fP"
.br
.ti -1c
.RI "\fBCOPDC\fP = \fBdata\fP[['COP']]\&.resample('1h')\&.mean()\&.interpolate()\&.sort_values('COP',ascending=False)\&.reset_index(drop=\fBTrue\fP)"
.br
.ti -1c
.RI "\fBdata\fP = data\&.resample(config['preprocessing']['ResampleTime'])\&.mean()\&.interpolate()"
.br
.RI "~~~~~~~~~~~~~~~~~~Milestone! "
.ti -1c
.RI "\fBdataAfternoon\fP = \fBTimeDivision\fP(\fBdataHourly\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataDaily\fP = \fBTimeDivision\fP(\fBdata\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataEvening\fP = \fBTimeDivision\fP(\fBdataHourly\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataHourly\fP = \fBTimeDivision\fP(\fBdata\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataMonthly\fP = \fBTimeDivision\fP(\fBdata\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataMorning\fP = \fBTimeDivision\fP(\fBdataHourly\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataNight\fP = \fBTimeDivision\fP(\fBdataHourly\fP,timeDivisionArray)"
.br
.ti -1c
.RI "\fBdataWeekly\fP = \fBTimeDivision\fP(\fBdata\fP,timeDivisionArray)"
.br
.ti -1c
.RI "tuple \fBdda\fP = degreeDays_delta_annemarie\&.sum()"
.br
.ti -1c
.RI "\fBddi\fP = degreeDays_indoor\&.sum()"
.br
.ti -1c
.RI "\fBddo\fP = degreeDays_outdoor\&.sum()"
.br
.ti -1c
.RI "\fBdefault\fP"
.br
.ti -1c
.RI "tuple \fBdegreeDays_delta_annemarie\fP = (\fBdata\fP['Tavg'] \- \fBdata\fP['Tamb'])\&.resample('1d')\&.mean()\&.interpolate()"
.br
.ti -1c
.RI "\fBdegreeDays_indoor\fP = \fBdata\fP['Tavg']\&.resample('1d')\&.mean()\&.interpolate()\&.apply(lambda x: 18 \- x if x > 18 else 0)"
.br
.ti -1c
.RI "\fBdegreeDays_outdoor\fP = \fBdata\fP['Tamb']\&.resample('1d')\&.mean()\&.interpolate()\&.apply(lambda x: 18 \- x if x > 18 else 0)"
.br
.ti -1c
.RI "\fBdf\fP = pd\&.DataFrame(fmf\&.error,\fBcolumns\fP=['index','error','c0','c1'])"
.br
.ti -1c
.RI "\fBDHSummerSlice\fP = \fBdata\fP[\fBThermalColumns\fP]\&.loc['{}\-05\-01'\&.format(\fByear\fP) : '{}\-07\-31'\&.format(\fByear\fP)]"
.br
.ti -1c
.RI "list \fBdhw\fP = [[\fBindex\fP,\fBdhw1\fP], [\fBindex\fP,\fBdhw2\fP], [\fBindex\fP,\fBdhw3\fP], [\fBindex\fP, \fBdhw4\fP], [\fBindex\fP, \fBdhw5\fP], [\fBindex\fP, \fBdhw6\fP], [\fBindex\fP, \fBdhw7\fP], [\fBindex\fP, \fBdhw8\fP]]"
.br
.RI "Domestic hot water lookup table\&. "
.ti -1c
.RI "list \fBdhw1\fP = []"
.br
.ti -1c
.RI "list \fBdhw2\fP = []"
.br
.ti -1c
.RI "list \fBdhw3\fP = []"
.br
.ti -1c
.RI "list \fBdhw4\fP = []"
.br
.ti -1c
.RI "list \fBdhw5\fP = []"
.br
.ti -1c
.RI "list \fBdhw6\fP = []"
.br
.ti -1c
.RI "list \fBdhw7\fP = []"
.br
.ti -1c
.RI "list \fBdhw8\fP = []"
.br
.ti -1c
.RI "\fBDHW_Baseline\fP = piv\&.mean(\fBaxis\fP=1)"
.br
.ti -1c
.RI "\fBDHWColumns\fP = config['preprocessing']['DHWColumns']\&.split(',')"
.br
.ti -1c
.RI "\fBdt\fP"
.br
.ti -1c
.RI "\fBdwstateColumns\fP = config['preprocessing']['DoorWindowStates']\&.split(',')"
.br
.ti -1c
.RI "\fBE_Baseline\fP = Epiv\&.mean(\fBaxis\fP=1)"
.br
.ti -1c
.RI "\fBEpiv\fP = pd\&.pivot_table(\fBdata\fP, \fBindex\fP=['hour'], \fBcolumns\fP=['day'], values=['Premainder'])"
.br
.ti -1c
.RI "\fBerrors\fP"
.br
.ti -1c
.RI "\fBEventConfig\fP = config['eventdetection'][\fBi\fP]\&.split(',')"
.br
.ti -1c
.RI "\fBEventData\fP = EventStudy\&.data[EventStudy\&.eventcolumns]"
.br
.ti -1c
.RI "list \fBEvents\fP = []"
.br
.ti -1c
.RI "\fBEventStudy\fP = \fBEventor\fP(data\&.loc[:, data\&.columns != 'DateTime'], VERBOSE=5)"
.br
.ti -1c
.RI "str \fBfigname\fP = '{}_data_processed'\&.format(config['preprocessing']['Filename']\&.split('\&.')[0])"
.br
.ti -1c
.RI "\fBFinalcategories\fP = pd\&.DataFrame(\fBCategoryWeights\fP[1:],\fBcolumns\fP=\fBCategoryWeights\fP[0], \fBindex\fP=[\fBi\fP[0] for \fBi\fP in \fBCategoryWeights\fP[1:]])\&.drop('Combined_Categories',\fBaxis\fP=1)"
.br
.ti -1c
.RI "\fBfmf\fP = \fBMultiFitter\fP(\fBInstance\fP,\fBlambdaMap\fP=\fBlambdaMap\fP,\fBlambdaDict\fP=\fBlambdaDict\fP,verbose=2)"
.br
.ti -1c
.RI "\fBFunction_List\fP = getmembers(analysis, isfunction)"
.br
.RI "~~~~~~~~~~~~~~~~~ USER ANALYSIS FUNCTION MAGIC ~~~~~~~~~~~~~~~~~#### "
.ti -1c
.RI "\fBgas\fP = int(config['schil']['gas'])"
.br
.ti -1c
.RI "\fBGenericConfig\fP = config['eventdetection']['GenericEvents']\&.split(',')"
.br
.ti -1c
.RI "str \fBHeaders\fP = '# Table Of Content\\n ' + '__'*100"
.br
.RI "Headers of document\&. "
.ti -1c
.RI "\fBhelp\fP"
.br
.ti -1c
.RI "\fBHPEColumns\fP = config['preprocessing']['HeatPumpElectric']\&.split(',')"
.br
.ti -1c
.RI "\fBHPTColumns\fP = config['preprocessing']['HeatPumpThermal']\&.split(',')"
.br
.ti -1c
.RI "\fBi\fP"
.br
.ti -1c
.RI "list \fBindex\fP = []"
.br
.ti -1c
.RI "\fBIndoor_temperatures\fP = config['preprocessing']['IndoorTemperatures']\&.split(',')"
.br
.ti -1c
.RI "\fBInhabitants\fP"
.br
.ti -1c
.RI "\fBinitPredictors\fP"
.br
.ti -1c
.RI "\fBinplace\fP"
.br
.ti -1c
.RI "\fBInstance\fP"
.br
.ti -1c
.RI "\fBj\fP"
.br
.ti -1c
.RI "\fBkind\fP"
.br
.ti -1c
.RI "\fBKNMI\fP = \fBKNMI_Resampler\fP(\fBpath\fP+'/uurgeg_290_2011\-2020\&.txt',\fBT_Columns\fP,\fBScaleArray\fP,header=28, Interval = '30min')"
.br
.ti -1c
.RI "dict \fBlambdaDict\fP"
.br
.ti -1c
.RI "dict \fBlambdaMap\fP"
.br
.ti -1c
.RI "\fBlegend\fP"
.br
.ti -1c
.RI "str \fBLog\fP = ''"
.br
.RI "Variable contains the generated Log, equal to code output in commandline\&. "
.ti -1c
.RI "\fBlongWindow\fP"
.br
.ti -1c
.RI "\fBlw\fP"
.br
.ti -1c
.RI "str \fBMODULE\fP = 'EtoP'"
.br
.RI "~~~~~~~~~~~~~~~~~~Milestone! "
.ti -1c
.RI "\fBmufit_html\fP = f\&.read()"
.br
.ti -1c
.RI "\fBnonexistent\fP"
.br
.ti -1c
.RI "\fBNormalizedEvents\fP = EventStudy\&.EventIndicer(threshold=float(config['eventdetection']['NormalizedEvents']))"
.br
.ti -1c
.RI "\fBNPColumns\fP = config['preprocessing']['NegativePower']\&.split(',')"
.br
.ti -1c
.RI "\fBOS\fP = os\&.environ\&.get('OS','')"
.br
.RI "Variable containing type of OS the code is running on\&. "
.ti -1c
.RI "\fBPandasDHWWrapper\fP"
.br
.ti -1c
.RI "\fBparser\fP = argparse\&.ArgumentParser()"
.br
.RI "Argument parser, filled with Commandline arguments\&. "
.ti -1c
.RI "\fBpath\fP = os\&.path\&.abspath(analysis\&.__file__)"
.br
.ti -1c
.RI "\fBPDC\fP = \fBdata\fP['Premainder']\&.resample('1h')\&.mean()\&.interpolate()\&.sort_values('Premainder',ascending=False)\&.reset_index(drop=\fBTrue\fP)"
.br
.ti -1c
.RI "\fBPdhw\fP"
.br
.ti -1c
.RI "\fBPdTtoV\fP"
.br
.ti -1c
.RI "\fBpiv\fP = pd\&.pivot_table(\fBdata\fP, \fBindex\fP=['hour'], \fBcolumns\fP=['day'], values=['Vdhwcal'])"
.br
.ti -1c
.RI "\fBpiv2\fP = piv\&.loc[:, (\fBpiv\fP != 0)\&.any(\fBaxis\fP=0)]"
.br
.ti -1c
.RI "\fBPPColumns\fP = config['preprocessing']['PositivePower']\&.split(',')"
.br
.ti -1c
.RI "\fBPredictedThermal\fP = pd\&.DataFrame(tp\&.Simulate(steps=tp\&.dataLength, err='HeatInput')[\-tp\&.dataLength:],\fBcolumns\fP=['index','err','HeatInput','HeatInput_pr','U','Ag','Ga','C'])"
.br
.ti -1c
.RI "\fBPVArea\fP = float(config['schil']['pvoppervlak'])"
.br
.ti -1c
.RI "\fBPVColumn\fP = config['preprocessing']['PVPanels']\&.split(',')"
.br
.ti -1c
.RI "\fBPVDC\fP = \fBdata\fP[['PVEfficiency']]\&.resample('1h')\&.mean()\&.interpolate()\&.sort_values('PVEfficiency',ascending=False)\&.reset_index(drop=\fBTrue\fP)"
.br
.ti -1c
.RI "\fBregressor\fP = LinearRegression()"
.br
.ti -1c
.RI "list \fBRevertArray\fP = []"
.br
.ti -1c
.RI "list \fBScaleArray\fP = [100*100\&.,1\&.0]"
.br
.ti -1c
.RI "\fBsd\fP"
.br
.ti -1c
.RI "\fBshortWindow\fP"
.br
.ti -1c
.RI "\fBSize\fP"
.br
.ti -1c
.RI "\fBSummerDetection\fP = pd\&.pivot_table(\fBdata\fP, \fBindex\fP=['hour'], \fBcolumns\fP=['day'], values= \fBThermalColumns\fP)"
.br
.ti -1c
.RI "\fBT1\fP"
.br
.ti -1c
.RI "\fBT2\fP"
.br
.ti -1c
.RI "list \fBT_Columns\fP = [' Q',' RH']"
.br
.ti -1c
.RI "\fBTDC\fP = \fBdata\fP[Ts]\&.resample('1h')\&.mean()\&.interpolate()\&.sort_values('dT',ascending=False)\&.reset_index(drop=\fBTrue\fP)"
.br
.ti -1c
.RI "\fBtest\fP = py2tex(\fBtex\fP,print_formula=False, print_latex=False, output='tex')\&.replace('$','')"
.br
.ti -1c
.RI "\fBtex\fP = \fBLambda2Tex\fP(\fBlambdaDict\fP[\fBi\fP])"
.br
.ti -1c
.RI "\fBThermalColumns\fP = config['preprocessing']['ThermalColumns']\&.split(',')"
.br
.ti -1c
.RI "dict \fBThermallambdaDict\fP"
.br
.ti -1c
.RI "dict \fBThermallambdaMap\fP"
.br
.ti -1c
.RI "\fBtitle\fP"
.br
.ti -1c
.RI "\fBtp\fP = \fBMultiFitter\fP(\fBInstance\fP,\fBlambdaMap\fP=\fBThermallambdaMap\fP,\fBlambdaDict\fP=\fBThermallambdaDict\fP,verbose=2)"
.br
.ti -1c
.RI "\fBTrue\fP"
.br
.ti -1c
.RI "\fBtype\fP"
.br
.ti -1c
.RI "int \fBVerbosity\fP = 1"
.br
.RI "For which level of knowledge to generate a report\&.ssss\&. "
.ti -1c
.RI "\fBverbosityLimit\fP"
.br
.ti -1c
.RI "tuple \fBwhite\fP = (255, 255, 255, 255)"
.br
.RI "Defining the color white for latex\&. "
.ti -1c
.RI "\fBX\fP = \fBdata\fP[['dT']]\&.interpolate()\&.bfill()\&.ffill()"
.br
.ti -1c
.RI "\fBy\fP = \fBdata\fP[['HeatInput']]"
.br
.ti -1c
.RI "\fBy_pred\fP = regressor\&.predict(\fBX\fP)"
.br
.ti -1c
.RI "list \fByear\fP = data\&.index[0]\&.year"
.br
.in -1c
.SH "Detailed Description"
.PP 
Defines smart meter data preprocessor\&. 


.SH "Description"
.PP
Defines the base and end user class for all fitting purposes, model and data agnostic
.IP "\(bu" 2
multifitter
.PP
.SH "Libraries/Modules"
.PP
.IP "\(bu" 2
random standard library (https://docs.python.org/3/library/random.html)
.IP "  \(bu" 4
Access to randint function\&.
.PP

.IP "\(bu" 2
argparse input argument parsing, adding options to command-line usage
.IP "\(bu" 2
pandas dataframe library
.IP "\(bu" 2
sys for handling files and folders and detecting OS
.IP "\(bu" 2
configparser for handling configuration/metadata files
.IP "\(bu" 2
warnings to create own warnings and ommit others
.IP "\(bu" 2
matplotlib plotting Library
.IP "\(bu" 2
sklearn for linear regressions on usage patterns/energy signatures
.IP "\(bu" 2
mufit multi fitter for model fitting library
.IP "\(bu" 2
inspect to convert code to pretty output and to generate equations
.IP "\(bu" 2
pytexit to generate latex equations
.IP "\(bu" 2
io for file/image handling\&. Internal image passing format\&.
.IP "\(bu" 2
os for OS detection and folder handling
.IP "\(bu" 2
PIL for internal image passing
.IP "\(bu" 2
copy for making pandas deepcopies
.IP "\(bu" 2
markdown for generating pretty output
.IP "\(bu" 2
datetime standard library
.PP
.SH "Notes"
.PP
.IP "\(bu" 2
This code expects a \&.CSV file with smart meter data with additional columns containing indoor and outdoor temperatures\&.
.IP "\(bu" 2
A \&.metadata file is filled according to a standard format
.IP "\(bu" 2
data will be read and manipulated according to instructions in the \&.metadata file
.PP
.SH "TODO"
.PP
.IP "\(bu" 2
Create Documentation
.IP "\(bu" 2
create visualization of inner workings
.IP "\(bu" 2
convert to powerpoint?
.IP "\(bu" 2
use data from chris to tune these models
.IP "\(bu" 2
annemarie: boxplot tool
.IP "\(bu" 2
EB monitorting: what to do with data
.PP
.SH "Author(s)"
.PP
.IP "\(bu" 2
Created by Jeroen van 't Ende 26/09/2024
.PP

.PP
Copyright (c) 2024 Jeroen van 't Ende\&. All rights reserved\&. 
.PP
Definition in file \fBpreProcessor\&.py\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Smart Meter Interpreter Documentation from the source code\&.
